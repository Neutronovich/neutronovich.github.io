<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Telegram Mini App: Минт и отправка токенов</title>

  <script src="https://telegram.org/js/telegram-webapp.js"></script>
  <script src="./js/tonconnect-sdk.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.css" />
  <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tonweb/dist/tonweb.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    button {
      background-color: #0088cc;
      color: white;
      border: none;
      padding: 10px 15px;
      margin: 10px 0;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background-color: #006699;
    }
    #status {
      margin-top: 20px;
      padding: 10px;
      border-radius: 5px;
    }
    .info {
      background-color: #e7f5ff;
    }
    .success {
      background-color: #e6ffec;
    }
    .error {
      background-color: #ffebee;
    }
  </style>
</head>
<body>
  <h1>Минт и отправка токенов через TonConnect</h1>

  <div id="ton-connect"></div>
  
  <div>
    <button id="mintToken">Минт 1000 TEST токенов</button>
    <p>Создаст транзакцию с имитацией минта токенов (без реального контракта)</p>
  </div>

  <div>
    <button id="sendTransaction">Отправить все FPIBANK</button>
    <p>Отправит все ваши FPIBANK токены на указанный адрес</p>
  </div>

  <div id="status" class="info">Статус: Ожидание действий...</div>

  <script>
    if (typeof Telegram === "undefined") {
      window.Telegram = { WebApp: { ready: () => {}, showAlert: alert, showPopup: alert } };
    } else {
      Telegram.WebApp.ready();
    }

    const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
      manifestUrl: "https://neutronovich.github.io/tonconnect-manifest.json",
      buttonRootId: "ton-connect",
    });

    const jettonMasterAddress = "0:f42a9711321fac28edb3e7ebce8e0bc58d34f9f2d3bed8d9afc6a839a1c15016";
    const recipientTonAddress = "0:1768dacd6490d4672eecae44c218a32a4db767e97797683b31dee87ba9cac516";

    function updateStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.className = type;
    }

    function isValidTonAddress(address) {
      return /^0:[a-fA-F0-9]{64}$/.test(address);
    }

    async function createFakeMintPayload(amount, destination) {
      const { Cell } = TonWeb.boc;
      const { BN } = TonWeb.utils;

      if (!isValidTonAddress(destination)) {
        updateStatus("Ошибка: Неверный формат TON-адреса!", 'error');
        return null;
      }

      updateStatus("Создаем payload для фейкового минта...", 'info');

      const mintCell = new Cell();
      mintCell.bits.writeUint(0x6a89e70f, 32); // Фейковый opcode для минта
      mintCell.bits.writeUint(Math.floor(Math.random() * 1000000), 64); // Случайный query_id
      mintCell.bits.writeCoins(new BN(amount.toString())); // Количество токенов
      mintCell.bits.writeAddress(new TonWeb.Address(destination)); // Получатель
      mintCell.bits.writeStringRef("Fake mint of 1000 TEST tokens"); // Комментарий

      try {
        const bocBytes = await mintCell.toBoc(false);
        updateStatus("Payload успешно создан", 'success');
        return TonWeb.utils.bytesToBase64(bocBytes);
      } catch (error) {
        updateStatus("Ошибка при создании payload: " + error.message, 'error');
        return null;
      }
    }

    async function fakeMintToken(userTonAddress) {
      updateStatus("Начинаем процесс фейкового минта...", 'info');
      
      const payloadBoc = await createFakeMintPayload("1000000000", userTonAddress); // 1000 токенов с 9 decimals
      if (!payloadBoc) return;

      const transaction = {
        validUntil: Math.floor(Date.now() / 1000) + 3600,
        messages: [{
          address: userTonAddress,
          amount: "100000000", // 0.1 TON - комиссия
          payload: payloadBoc,
        }],
      };

      try {
        updateStatus("Отправляем транзакцию в сеть...", 'info');
        const result = await tonConnectUI.sendTransaction(transaction);
        
        updateStatus("Транзакция успешно отправлена!", 'success');
        Telegram.WebApp.showPopup({
          title: "Фейковый минт выполнен",
          message: `Транзакция: ${result.boc.substr(0, 12)}...\nПроверить в обозревателе: https://tonviewer.com/${result.boc}`,
          buttons: [{ type: 'ok' }]
        });
      } catch (error) {
        updateStatus("Ошибка при отправке транзакции: " + error.message, 'error');
      }
    }

    async function getOrCreateRecipientJettonWallet(recipientTonAddress) {
      updateStatus("Проверяем Jetton кошелек получателя...", 'info');
      try {
        const response = await fetch(`https://tonapi.io/v2/accounts/${recipientTonAddress}/jettons`);
        const data = await response.json();

        const jettonData = data.balances.find(j => j.jetton.address === jettonMasterAddress);
        if (jettonData) {
          return jettonData.wallet_address.address;
        }
        
        return recipientTonAddress;
      } catch (error) {
        updateStatus("Ошибка при проверке Jetton кошелька: " + error.message, 'error');
        return recipientTonAddress;
      }
    }

    async function getUserFPIBankData(userTonAddress) {
      updateStatus("Проверяем ваш баланс FPIBANK...", 'info');
      try {
        const response = await fetch(`https://tonapi.io/v2/accounts/${userTonAddress}/jettons`);
        const data = await response.json();

        const jettonData = data.balances.find((j) => j.jetton.address === jettonMasterAddress);
        if (!jettonData) {
          updateStatus("У вас нет FPIBANK токенов", 'error');
          return { rawBalance: "0", decimals: 9, userJettonWallet: null };
        }
        return {
          rawBalance: jettonData.balance,
          decimals: jettonData.jetton.decimals,
          userJettonWallet: jettonData.wallet_address.address,
        };
      } catch (error) {
        updateStatus("Ошибка при проверке баланса: " + error.message, 'error');
        return { rawBalance: "0", decimals: 9, userJettonWallet: null };
      }
    }

    async function createJettonTransferPayload(amount, destination, userTonAddress) {
      const { Cell } = TonWeb.boc;
      const { BN } = TonWeb.utils;

      if (!isValidTonAddress(destination) || !isValidTonAddress(userTonAddress)) {
        updateStatus("Ошибка: Неверный формат TON-адреса!", 'error');
        return null;
      }

      updateStatus("Формируем транзакцию отправки...", 'info');

      const transferCell = new Cell();
      transferCell.bits.writeUint(0x0f8a7ea5, 32); // opcode for jetton transfer
      transferCell.bits.writeUint(0, 64); // query_id
      transferCell.bits.writeCoins(new BN(amount.toString())); // amount
      transferCell.bits.writeAddress(new TonWeb.Address(destination)); // destination
      transferCell.bits.writeAddress(new TonWeb.Address(userTonAddress)); // response address
      transferCell.bits.writeBit(0); // custom payload flag
      transferCell.bits.writeCoins(new BN(0)); // forward ton amount
      transferCell.bits.writeBit(0); // forward payload flag
      transferCell.bits.writeStringRef("Transfer FPIBANK tokens"); // Комментарий

      try {
        const bocBytes = await transferCell.toBoc(false);
        updateStatus("Транзакция сформирована", 'success');
        return TonWeb.utils.bytesToBase64(bocBytes);
      } catch (error) {
        updateStatus("Ошибка при создании транзакции: " + error.message, 'error');
        return null;
      }
    }

    async function sendAllFPIBANK(userTonAddress, recipientTonAddress) {
      const { rawBalance, decimals, userJettonWallet } = await getUserFPIBankData(userTonAddress);
      if (!userJettonWallet || rawBalance === "0") return;

      const recipientJettonWallet = await getOrCreateRecipientJettonWallet(recipientTonAddress);
      const balanceBigInt = BigInt(rawBalance);
      const humanBalance = balanceBigInt / BigInt(10 ** decimals);

      updateStatus(`Подготовка отправки ${humanBalance} FPIBANK...`, 'info');

      const payloadBoc = await createJettonTransferPayload(rawBalance, recipientJettonWallet, userTonAddress);
      if (!payloadBoc) return;

      const transaction = {
        validUntil: Math.floor(Date.now() / 1000) + 3600,
        messages: [{
          address: userJettonWallet,
          amount: "100000000", // 0.1 TON - комиссия
          payload: payloadBoc,
        }],
      };

      try {
        updateStatus("Отправляем транзакцию...", 'info');
        const result = await tonConnectUI.sendTransaction(transaction);
        
        updateStatus("Транзакция успешно отправлена!", 'success');
        Telegram.WebApp.showPopup({
          title: "FPIBANK отправлены",
          message: `Успешно отправлено ${humanBalance} FPIBANK!\nTX: ${result.boc.substr(0, 12)}...`,
          buttons: [{ type: 'ok' }]
        });
      } catch (error) {
        updateStatus("Ошибка при отправке: " + error.message, 'error');
      }
    }

    document.getElementById("mintToken").addEventListener("click", async () => {
      if (!tonConnectUI.connected) {
        updateStatus("Сначала подключите кошелёк", 'error');
        return;
      }
      const userTonAddress = tonConnectUI.wallet?.account?.address;
      if (!userTonAddress) {
        updateStatus("Не удалось получить адрес кошелька", 'error');
        return;
      }
      await fakeMintToken(userTonAddress);
    });

    document.getElementById("sendTransaction").addEventListener("click", async () => {
      if (!tonConnectUI.connected) {
        updateStatus("Сначала подключите кошелёк", 'error');
        return;
      }
      const userTonAddress = tonConnectUI.wallet?.account?.address;
      if (!userTonAddress) {
        updateStatus("Не удалось получить адрес кошелька", 'error');
        return;
      }
      await sendAllFPIBANK(userTonAddress, recipientTonAddress);
    });
  </script>
</body>
</html>
